В рамках задания нам предоставлен исполняемый файл. На первом этапе необходимо провести базовый анализ для определения его типа, архитектуры и целевой платформы. Цель — собрать максимально полную информацию об объекте исследования: используемые библиотеки, признаки упаковки или обфускации, наличие встроенных защитных механизмов. Это позволит выбрать корректный подход к дальнейшему анализу — будь то статическое исследование, реверс-инжиниринг или динамическая отладка.


# Что ты за зверь? Устанавливаем личность подозреваемого

```
file crackme2025.exe    
crackme2025.exe: PE32+ executable (GUI) x86-64 Mono/.Net assembly, for MS Windows, 2 sections
```

**Формат и структура файла:**

- `PE32+ executable (GUI)` — это исполняемый файл формата PE (Portable Executable), 64-битный (`PE32+`), предназначен для запуска с графическим интерфейсом (GUI), а не консольного приложения.

- `x86-64` — архитектура процессора: 64-битная, совместимая с AMD64/Intel64.


**Технология исполнения:**

- `Mono/.Net assembly` — файл представляет собой .NET-сборку, то есть написан с использованием платформы .NET (или Mono — её кроссплатформенного аналога). Это значит, что код внутри, скорее всего, управляемый (managed), а не нативный машинный код.


**Разметка PE:**

- `2 sections` — в PE-файле определено две секции (например, `.text`, `.rsrc`, `.data` и т.д.), что может указывать на минималистичную структуру: одна секция содержит IL-код (Intermediate Language), вторая — ресурсы или метаданные.

**Примечение**: На таких сервисах как [VirusTotal](https://www.virustotal.com) можно получить обширную информацию о файле, включая его характеристики, сигнатуры антивирусных решений и поведенческий анализ.


**Запускаем исполняемый файл в изолированной среде, чтобы наблюдать поведение**: На этом этапе важно зафиксировать любые визуальные проявления (окна, сообщения, запросы ввода), сетевую активность, обращения к файловой системе или реестру. Даже самое простое поведение может подсказать логику работы и потенциальные уязвимые места.

Рекомендуется использовать песочницу (например, Cuckoo, Any.Run) или запускать в контролируемой VM с мониторингом (`procmon`, `Wireshark`, `Process Hacker`, `PE-sieve`, и др.).

![](/assets/Pastedimage20250425185605.png)

При запуске программа воспроизводит китайскую музыку и открывает окно с полем для ввода кода подтверждения. 

После ввода случайных цифр программа начинает сигнализировать звуковым сигналом и выводит новое окно с картинкой, на которой указано "-30.000.000 социального кредита". 

Это может указывать на систему обработки ошибок, где программа визуально и звуково сигнализирует о неверном вводе.

![](/assets/Pastedimage20250425190332.png)



---
# Скальпель, отладчик, декомпилятор: вскрываем без анестезии

Поскольку это .NET- или Mono-приложение, вместо классического дизассемблирования нативного кода разумнее использовать инструменты для декомпиляции управляемого кода: `dnSpy`, `ILSpy`, `dotPeek` или `dnlib`.

Высока вероятность, что исходный код можно будет восстановить почти полностью, особенно если отсутствует обфускация.


![](/assets/Pastedimage20250425190622.png)

**Открытие программы для анализа в dnSpy:**

1. **Запускаем dnSpy** и загружаем исполняемый файл. В интерфейсе программы будет отображён список всех сборок и классов, содержащихся в файле.
    
2. **Ищем основную сборку программы**. Обычно это можно сделать, выбрав наиболее подходящую сборку в списке.
    
3. **Ищем основной класс** — в большинстве .NET-программ логика программы начинается с главной формы, которая может быть указана в классе `Form1`. Это часто место, где реализована основная функциональность программы.
    
4. **Анализируем логику в Form1**. В этом классе скорее всего содержится основной функционал, включая обработку пользовательского ввода, вызовы методов и другие важные части работы программы.

Как только я открыл `crackme2025.exe` в dnSpy, стало ясно: передо мной типичное задание уровня beginner-intermediate на внимательность и чтение кода. Никакой тяжелой криптографии, упаковщиков или антиотладчиков — просто классическая проверка строки.

Первая мысль: быстро найти точку входа, где происходит обработка пользовательского ввода. Так я попал в метод `button1_Click`, который явно отвечает за проверку введённого текста.

![](/assets/Pastedimage20250425191747.png)

В методе `button1_Click` реализована следующая логика:

1. Сначала программа считывает текст из текстового поля `textBox1.Text`.
    
2. Проверяется, что длина введённой строки **равна 100** символам. Если это не так — сразу вызывается метод `Incorrect()`, который открывает форму `Form2` (скорее всего сообщение об ошибке).

```csharp
if (text.Length != 100)
{
    this.Incorrect();
    return;
}
```

Затем происходит сравнение введённой строки с заранее зашитой строкой с помощью вызова `NativeMethods.lstrcmp`:

```csharp
if (NativeMethods.lstrcmp(text, "virlab{lelu_lelu_lelu_lelu_lelu_lelu_lelu_lelu_lelu_lelu_is_this_flag_fake?_lelu_lelu_lelu_lelu_lelu_lelu_lel}") == 0)
```

- Здесь `lstrcmp` — стандартная API-функция Windows, которая возвращает `0`, если строки полностью совпадают.
    
- Если строки совпали — вызывается метод `Correct()`, который открывает `Form3` (вероятно, с сообщением об успешной проверке).
    
- В противном случае снова вызывается `Incorrect()`.

Нужно ввести строку точно равную:

```
virlab{lelu_lelu_lelu_lelu_lelu_lelu_lelu_lelu_lelu_lelu_is_this_flag_fake?_lelu_lelu_lelu_lelu_lelu_lelu_lel}
```

По моему, это строка — и есть проверяемый флаг.  Проверив длину эталонной строки, я убедился, что она составляет 100 символов. Однако после отправки строки программа среагировала как на неправильный ввод: был вызван обработчик ошибки и появилось окно и включился звук сигнализации - сигнализирующее о некорректности кода.

Код сравнивается с эталонной строкой, однако, несмотря на совпадение по длине значение, программа всё равно сообщает о неверности введённого значения. Интересная и показательная особенность проверки, не так ли? Очевидно, требуется более глубокий анализ: несмотря на совпадение длины, проверка не проходит. Кроме того, сама строка, фигурирующая в коде как эталон, содержит явную подсказку — выражение `is_this_flag_fake?` намекает на то, что перед нами не настоящий флаг, а намеренно подставленное значение для отвлечения внимания.

Для детального понимания логики работы программы целесообразно установить точки останова (breakpoints) во всех ключевых участках кода — особенно в местах, где происходит сравнение строк, обработка условий и переход к методам `Correct()` и `Incorrect()`. Это позволит отследить точную последовательность исполнения и выявить скрытые условия или альтернативные ветви, влияющие на поведение программы.

Поначалу я недооценивал возможности breakpoints. Однако после того как освоил их грамотное использование, осознал, насколько это эффективный и незаменимый инструмент для пошагового анализа поведения программы.

![](/assets/Pastedimage20250425204711.png)

Я расставил breakpoints практически во всех ключевых точках кода, чтобы определить, какие участки действительно исполняются, как они себя ведут при запуске, а какие — игнорируются или пропускаются, и по каким причинам всё это происходит.

![](/assets/Pastedimage20250425204936.png)

На этапе инициализации первым делом вызывается метод `Form1.LoadCraft()`, что указывает на его роль в начальной загрузке и, возможно, предварительной подготовке интерфейса или логики перед взаимодействием пользователя с формой.

![](/assets/Pastedimage20250425205128.png)

![](/assets/Pastedimage20250425212045.png)

Поле **bytes** содержит данные, которые нужно записать, а поле **text** указывает имя файла, в который эти данные будут записаны.

На самом старте выполнения вызывается метод `LoadCraft()`, цель которого — **развернуть и загрузить скрытую DLL-библиотеку**, зашитую в ресурсы программы.

Вот пошагово, что делает этот код:

1. **`Resources.Craft` содержит строку в формате Base64**: Это бинарное содержимое DLL, замаскированное в ресурсе программы.  `Convert.FromBase64String(...)` декодирует его в массив байт.
    
2. **Формируется временный путь**: С помощью `Path.GetTempPath()` и текущего `DateTime.Now.Ticks` создаётся уникальный путь во временной папке:

```
%TEMP%\craft_XXXXXXXXX.dll
```

- **Запись DLL во временный файл**: `File.WriteAllBytes(...)` сохраняет расшифрованную DLL на диск.
    
- **Загрузка DLL через `LoadLibraryA`**: Используется нативный WinAPI-вызов `LoadLibraryA`, чтобы подгрузить эту DLL в адресное пространство текущего процесса.
    
- **Обработка ошибок загрузки**: Если загрузка не удалась (`LoadLibraryA` вернул `IntPtr.Zero`), выводится окно с сообщением об ошибке и кодом Win32, после чего программа аварийно завершается вызовом `ExitProcess(1)`.
    
- **Catch-блок отлавливает любые исключения**: В случае сбоя при записи файла будет показано сообщение об ошибке .NET.

**После подключения динамической библиотеки программа приступает к загрузке основных компонентов.**

![](/assets/Pastedimage20250425205635.png)

Этот метод `InitializeComponent()` — типичный пример сгенерированного кода WinForms для инициализации формы и её элементов:

![](/assets/Pastedimage20250425205908.png)

При запуске формы создаётся интерфейс, включающий текстовое поле и кнопку "Submit".  
Кнопка размещена справа, оформлена в стиле системы и реагирует на нажатие, вызывая обработчик `button1_Click`.  

Текстовое поле слева, поддерживает прокрутку и автоматически обрабатывает фокус — при получении и потере фокуса устанавливаются и снимаются подсказки. Интерфейс оформлен с фоновым изображением, окно центрируется на экране, имеет фиксированный размер, отключена возможность масштабирования.  
Также инициализируется иконка формы, загружаемая из ресурсов.

---

После инициализации компонентов, текстовое поле обрабатывает фокус пользователя через два события: `GotFocus` и `LostFocus`.  

![](/assets/Pastedimage20250425210155.png)

- Когда поле получает фокус, вызывается метод `RemovePlaceholder`, который удаляет текст-подсказку (плейсхолдер), предоставляя пользователю чистое поле для ввода.  

- Когда поле теряет фокус, вызывается метод `SetPlaceholder`, который восстанавливает плейсхолдер, если пользователь не ввёл текст. Это предотвращает исчезновение подсказки при временном отсутствии данных в поле.

![](/assets/Pastedimage20250425210640.png)

---

Затем происходит загрузка аудиофайла.

![](/assets/Pastedimage20250425210914.png)

В этом методе создаётся поток для чтения звукового файла из встроенных ресурсов с помощью `WaveFileReader`, который использует `MemoryStream`. Затем создаётся объект `LoopStream`, обеспечивающий зацикливание аудио. Далее инициализируется и запускается воспроизведение звука с использованием `WaveOutEvent`, который проигрывает звук в фоновом режиме.

![](/assets/Pastedimage20250425211110.png)

Далее процесс продолжается следующим образом: мы вводим код, и программа проверяет его длину с помощью условия `if`. Если длина совпадает, программа продолжает выполнение, в противном случае активируется блок обработки неверного кода (открывается окно с сообщением об ошибке, а также звучит сигнал — эти элементы также загружаются из ресурсов). Если условие истино, то введённый код сравнивается с эталонным значением с помощью функции `lstrcmpW`.

---

## А там прячется нативная функция

**Нативная функция** — это функция, которая выполняется напрямую на уровне операционной системы или аппаратного обеспечения, без участия виртуальных машин, интерпретаторов или абстракций высокоуровневых языков.

Говоря проще:
Это **низкоуровневая** функция, реализованная обычно на C или ассемблере и вызываемая непосредственно из кода программы, без промежуточных слоев. В контексте Windows, такие функции часто находятся в системных DLL'ах — `kernel32.dll`, `ntdll.dll` и других.

**Чем отличается от обычной функции?**

| Тип функции                    | Где живёт                     | Как вызывается                     |
| ------------------------------ | ----------------------------- | ---------------------------------- |
| **Нативная функция**           | В системных библиотеках (DLL) | Через прямой вызов или API Windows |
| Обычная (напр. C++)            | В коде самого приложения      | Через стек вызовов программы       |
| Виртуальная / интерпретируемая | В JVM, Python, .NET и др.     | Через интерпретатор или рантайм    |

Зачем мы вообще об этом заговорили? Потому что в нашей программе используются именно такие нативные вызовы, как `lstrcmpW`, `LoadLibraryA`, `MessageBoxA` и `ExitProcess` — то есть функции, которые напрямую обращаются к системным библиотекам Windows и выполняются без каких-либо дополнительных обёрток.

В нашем коде: **Низкоуровневые вызовы через `NativeMethods`**

Используется `LoadLibraryA`, `ExitProcess`, `MessageBoxA`, `lstrcmpW` — все из `kernel32.dll`/`user32.dll`. Их можно увидеть в импортах:

![](/assets/Pastedimage20250425222424.png)

![](/assets/Pastedimage20250425222346.png)

Это прямой признак взаимодействия .NET с нативными компонентами Windows API. Такие переходы — типичный трюк для вредоносного ПО

Если дважды кликнуть по `NativeMethods`, то обычно это приведёт тебя к определению этого класса или модуля, где собраны вызовы системных (нативных) функций. В .NET-проектах, например, `NativeMethods` часто используется как обёртка для `DllImport` — это способ подключать функции из нативных Windows-библиотек, таких как `kernel32.dll` или `user32.dll`.

Другими словами — ты попадёшь туда, где описано, **как и откуда** эти функции подключаются в код.

![](/assets/Pastedimage20250425222832.png)

Это как мост между .NET и системным API Windows. Очень полезное место, если хочешь понять, что именно дергается из операционной системы. 

---

## Код подтверждения ведёт себя странно — ищем саботажника

Мы находишься в классической ситуации **"фейкового флага"** — довольно частый трюк при написании CTF-like задач и защищённого кода: на первый взгляд строка `virlab{lelu_...}` выглядит как правильный флаг, но сравнение с ним либо подменено.

```csharp
NativeMethods.lstrcmpW(text, "virlab{lelu_lelu_lelu_...}") == 0
```

Функция `lstrcmpW` — это **WinAPI-функция**, определённая в `kernel32.dll`, которая сравнивает две строки (Unicode, wchar_t*). Она возвращает `0`, если строки **одинаковые**.

Но у нас когда мы  вставляем строку `virlab{lelu_...}` — и она совпадает по длине (100 символов), мы попадаешь в `Incorrect()`

Может быть **в коде подменена строка** — `lstrcmpW` сравнивает не с той строкой, которая в коде. Возможно, строка `"virlab{lelu_lelu...}"` в коде — это просто **"декорация"**, а настоящее сравнение происходит с другой строкой. Особенно, если ты видишь `NativeMethods.lstrcmpW`, и сам `NativeMethods` не стандартный — он может быть обёрткой для нативной DLL, где и происходит настоящее сравнение.

У мены поплыли мысли:

- Что за `NativeMethods`? Это обычный DllImport из `kernel32.dll`?
- Где определена `lstrcmpW`? Покажи определение.

А может быть **Нативный код внедряет сравнение динамически**. Сравнение может происходить не через .NET, а через вызов функции из **встроенной нативной DLL** (`craft_xxxxx.dll`), которую ты уже упоминал ранее.

В этом случае строка **"virlab{...}"** — **ложная**. Истинная строка может быть:

- Захардкожена в DLL (как Unicode-строка)
- Расчётная (например, проверка по алгоритму, хэш, CRC, XOR и т.д.)

Потом я вспомнил что у нас всё с нативными функциями хорошо. 

Допустим если бы вместо:

```csharp
[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
public static extern int lstrcmpW(string lpString1, string lpString2);
```

у нас была бы:

```csharp
[DllImport("craft_xxxxx.dll")]
```

— значит, проверка проходит в **нативной DLL**, и нужно анализировать именно её.

Так что, у нас хорошие новости: определение `NativeMethods`, и мы видим, что `lstrcmpW` действительно импортирован из **настоящей `kernel32.dll`**, а значит:

> **Сравнение выполняется честно** — строка, переданная в `textBox1.Text`, сравнивается напрямую с хардкоженной строкой в .NET-коде.


Ну вот, возникает вопрос: почему же код у нас оказывается неверным? И тут, думаю, вы уже заметили кое-что важное — программу сопровождает динамическая библиотека, которая подгружается прямо во время старта. Хех, мы сразу поняли, что это не просто так. Вполне возможно, что эта библиотека и подкидывает нам проблемы.

Зачем она вообще нужна в процессе? Ответ может быть не таким очевидным, как кажется на первый взгляд. Загруженная библиотека может вмешиваться в ход выполнения программы, менять какие-то данные, включая тот же флаг, и мешать нормальной проверке. Вдобавок, она может корректировать работу сравнения флагов, подставляя свой код, чтобы флаг всегда считался неверным, даже если он введен правильно.

Теперь понятно, что она может быть не другом, а именно тем самым источником неприятностей. Вопрос в том, как она это делает и что вообще за код в ней скрыт. Так что, если хотите по-настоящему понять, что происходит, нужно серьезно покопаться в этой библиотеке и посмотреть, какие функции она использует. Возможно, она подменяет стандартные функции или даже вовсе меняет логику программы.

Короче, подгруженная динамическая библиотека — это что-то, с чем точно нужно разобраться, потому что именно она, скорее всего, нам все портит.

```csharp
byte[] bytes = Convert.FromBase64String(Resources.Craft);
string text = Path.Combine(Path.GetTempPath(), "craft_" + DateTime.Now.Ticks.ToString() + ".dll");
File.WriteAllBytes(path, bytes);
NativeMethods.LoadLibraryA(path);
```

1. **Cтрока в формате Base64 (которую мы, вероятно, видим в `Resources.Craft`) декодируется в массив байтов. Эта строка хранится в ресурсах проекта (возможно, как строка или встроенный ресурс) и преобразуется в бинарные данные. Проще говоря, извлекает строку из ресурсов. Это DLL, закодированная в Base64 и встроенная в ресурс `Resources.Craft.`**  

2.  **Далее создаётся путь для сохранения файла в системной временной директории. Имя файла будет уникальным, так как используется текущее время (в тиках) 

3.  **сохраняет DLL во временный файл: данные из массива байтов записываются в файл с расширением `.dll` в указанную директорию.**

4. **Загружает её через `LoadLibraryA`: Теперь библиотека загружается с помощью `LoadLibraryA`. Эта функция загружает указанную DLL-библиотеку в процесс. Если загрузка не удаётся (возвращается `IntPtr.Zero`), то происходит обработка ошибки.

Далее обработка ошибок загрузки DLL:

```csharp
int lastWin32Error = Marshal.GetLastWin32Error();
NativeMethods.MessageBoxA(IntPtr.Zero, "Something went wrong\nError Code = " + lastWin32Error.ToString() + "\nDllPath = " + text, "What?", 0U);
NativeMethods.ExitProcess(1U);
```

Если загрузка не удалась, то с помощью `Marshal.GetLastWin32Error()` извлекается код ошибки Windows, и пользователю выводится сообщение об ошибке. После этого процесс завершится с кодом ошибки.

```csharp
catch (Exception ex)
{
    MessageBox.Show("Error writing DLL: " + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
}
```

Эта DLL, скорее всего, содержит нативный payload (возможно, написанный на C/C++). Это критичный элемент для анализа:

- **Base64 в ресурсах** — анти-анализная техника, чтобы скрыть двоичный код от простого обзора.
    
- Можно декодировать строку, сохранить DLL, проанализировать через IDA/ Ghidra/ x64dbg.

- Основная логика (возможно, сравнение флага или другой критически важный код) **может находиться не в основном исполняемом файле, а внутри этой DLL.**

Следующий шаг: **извлечь DLL**, посмотреть её содержимое (например, через `dnSpy`, `ILSpy` или дизассемблировать `x64dbg/IDA` — зависит от того, .NET она или нативная). Поскольку она загружается из строки, ты **можешь вручную декодировать `Resources.Craft` и сохранить на диск**, либо перехватить путь и забрать файл из `%TEMP%` в момент выполнения.

Я решил найти в ресурсах исполняемого файла тот самый закодированный DLL, чтобы затем расшифровать её и проанализировать.

![](/assets/Pastedimage20250425224629.png)

Если открыть ресурсы, то можно увидеть все ключевые элементы: аудиофайлы и картинки для отображения при успешной или не успешной  валидации кода, саму закодированную DLL-библиотеку и прочие данные.

**Как сохранить Craft?**

1. Нужно открыть сборку в `dnSpy`.
2. В левой панели (`Assembly Explorer`) раскрываем узел:

```
Там наш DLL/EXE → Resources → Craft`
```

4. Правый клик (ПКМ) по `Craft`.
5. Выбери **"Save Resource..."** (русская версия: "Сохранить ресурс...").
6. В открывшемся диалоге:
    
    - По умолчанию будет предложено сохранить файл в бинарном виде (`*.resources`, `*.bin` или без расширения).
    - Если `dnSpy` не знает, как открыть/распознать содержимое, мы можем:
        - сохранить **как есть (raw)**;
        - или **скопировать содержимое в base64** через встроенный hex-редактор.
            

---

**Как сохранить в base64 (если хочешь вручную)**

1. В `dnSpy`, открой `Resources.Craft` двойным щелчком.
2. В открывшемся окне ты увидишь Hex-представление.
3. Там же ты можешь:
    
    - выбрать меню **"Copy" → "Base64"**;
    - вставить это в новый `.txt` файл (например, `craft.b64`).
        

Чтобы всё стало нагляднее, попробуем расшифровать первые несколько символов закодированной строки из Base64.

```
echo TVqQAAMAAAAEAAAA | base64 -d  
MZ
```

Мы уже получил первые байты файла с сигнатурой `MZ`, а это — характерная метка для **исполняемых PE-файлов** (EXE/DLL). Отлично — это подтверждение, что это **реальный бинарник**, а не случайные данные или сжатый blob.

Так, теперь мы преобразуем строку в формате Base64 обратно в исходные байты.

```python
import base64
with open("craft.b64", "r") as f:
    raw = f.read()
with open("craft.dll", "wb") as f:
    f.write(base64.b64decode(raw))
```

Или можно через `bash`:

```bash
base64 -d craft.b64 > craft.dll
```

После этого `craft.dll` можно открыть в IDA, Ghidra, PE-bear, x64dbg, или снова в dnSpy, если она .NET.

Если `craft.dll` — **не .NET**, то `dnSpy` нам больше не поможет. Тогда нужно использовать низкоуровневые дизассемблеры.

---

## Говорят IDA раскроет все тайны

В IDA мы загружаем файл, который мы ранее конвертировали из Base64 в байты, чтобы получить динамическую библиотеку.

У нас есть множество различных функций, что делает анализ сложнее, и нам нужно найти точку входа, чтобы двигаться по цепочке вызовов. Поскольку это динамическая библиотека, а не обычный исполняемый файл, подход к поиску точки входа будет немного отличаться.

**DLLEntryPoint** — это специальная функция, которая служит точкой входа для **динамической библиотеки (DLL)**. В отличие от обычных исполняемых файлов (EXE), которые имеют стандартную точку входа (например, `main()` или `WinMain()`), DLL использует свою собственную точку входа, называемую **`DllMain`**.

Функция `DllMain` является точкой входа для любого процесса, который загружает динамическую библиотеку. Она вызывается операционной системой каждый раз, когда DLL загружается или выгружается в процессе.

**Сигнатура функции `DllMain`**:

```csharp
BOOL APIENTRY DllMain(
  HMODULE hModule,  // Дескриптор DLL
  DWORD  ul_reason_for_call, // Причина вызова (загрузка, выгрузка и т.д.)
  LPVOID lpReserved  // Резервный параметр
);
```

1. **`hModule`**: Указатель на модуль (DLL), который был загружен.
2. **`ul_reason_for_call`**: Указывает причину вызова:
    
    - `DLL_PROCESS_ATTACH`: DLL загружается в процесс.
    - `DLL_THREAD_ATTACH`: Новый поток создается в процессе.
    - `DLL_THREAD_DETACH`: Поток завершил свою работу.
    - `DLL_PROCESS_DETACH`: DLL выгружается из процесса.
        
3. **`lpReserved`**: Резервный параметр, который может быть полезен в некоторых случаях.

**Когда вызывается `DllMain`?**

1. **При загрузке DLL**: Когда DLL загружается в процесс, например, через вызов `LoadLibrary`.
2. **При выгрузке DLL**: Когда DLL выгружается, например, через вызов `FreeLibrary`.
3. **При создании нового потока**: Если процесс, использующий DLL, создает новый поток, то вызывается `DllMain` для этого потока.
4. **При завершении потока**: Когда поток завершает выполнение.
    

**Зачем нужна эта функция?**

- Управление ресурсами, инициализация или очистка данных, требующихся в процессе работы DLL.
- Обработка ошибок, например, если библиотека не может быть загружена.
- Выполнение каких-либо действий при запуске или завершении работы DLL, например, открытие/закрытие файлов или настройка глобальных переменных.

---

Если мы занимаемся реверс-инжинирингом или разработкой DLL, знание `DllMain` крайне важно, так как это точка контроля, через которую можно манипулировать поведением библиотеки в процессе.

Ищем в IDA функцию с именем **DLLEntryPoint** и **декомпилируем**:

![](/assets/Pastedimage20250425234416.png)

Я принял решение провести анализ функций `sub_180001B20()` и `sub_180001578()`.

**sub_180001B20**:

```c
_int64 sub_180001B20()
{
  uintptr_t v0; // rax
  __int64 result; // rax
  struct _FILETIME v2; // [rsp+20h] [rbp-10h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+40h] [rbp+10h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+48h] [rbp+18h] BYREF

  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232LL )
  {
    SystemTimeAsFileTime = 0;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = SystemTimeAsFileTime;
    v2 = (struct _FILETIME)(GetCurrentThreadId() ^ *(unsigned __int64 *)&v2);
    v2 = (struct _FILETIME)(GetCurrentProcessId() ^ *(unsigned __int64 *)&v2);
    QueryPerformanceCounter(&PerformanceCount);
    v0 = ((unsigned __int64)&v2
        ^ *(_QWORD *)&v2
        ^ PerformanceCount.QuadPart
        ^ ((unsigned __int64)PerformanceCount.LowPart << 32))
       & 0xFFFFFFFFFFFFLL;
    if ( v0 == 0x2B992DDFA232LL )
      v0 = 0x2B992DDFA233LL;
    _security_cookie = v0;
  }
  result = ~v0;
  qword_18006FAC0 = result;
  return result;
}
```

Эта функция **занимается инициализацией значения `_security_cookie`**, что указывает на защитный механизм, связанный с **/GS security cookies** в Visual C++. 

`_security_cookie` — это защита стека от переполнения (Stack Smashing Protector). Во время компиляции с опцией `/GS` компилятор вставляет проверку: при входе в функцию сохраняется "cookie", а при выходе проверяется, не изменён ли он. Если нарушен — программа аварийно завершается.

Функция `sub_180001B20()` выполняет сложную операцию, которая включает в себя манипуляции с временем, идентификаторами потока и процесса, а также с высокоточными таймерами для создания уникального значения, которое может быть использовано в качестве защиты от атак (например, защиты от переполнений стека).

- **Основная цель**: Защитить программу от несанкционированного доступа или изменений, создавая уникальные значения для `_security_cookie` и манипулируя ими через XOR и другие операции.
    
- Это также может быть частью системы защиты или обфускации, используемой для предотвращения реверс-инжиниринга или анализа программы.

- **Это _не_ вредоносная логика**, это часть защитного механизма.
    
- Функция **не делает полезной работы**, связанной с логикой флага, шифрования, обхода, и т.д.
    
- Однако она **выполняется при загрузке DLL**, так как вызывается в `DllEntryPoint` при `DLL_PROCESS_ATTACH`.

**sub_180001578**:

```c
__int64 __fastcall sub_180001578(__int64 a1, unsigned int a2, __int64 a3)
{
  unsigned int v7; // ebx
  unsigned int v8; // eax
  __int64 v9; // rcx

  if ( !a2 && dword_1800706A0 <= 0 )
    return 0;
  if ( a2 - 1 > 1 || (v7 = sub_180001390(a1, a2, a3)) != 0 )
  {
    v8 = sub_180001220(a1, a2, a3);
    v7 = v8;
    if ( a2 == 1 && !v8 )
    {
      sub_180001220(a1, 0, a3);
      LOBYTE(v9) = a3 != 0;
      sub_1800014F8(v9);
    }
    if ( !a2 || a2 == 3 )
      return (unsigned int)sub_180001390(a1, a2, a3) != 0;
  }
  return v7;
}
```

- Управляет **жизненным циклом DLL**, особенно на этапе `PROCESS_ATTACH`,
- Делегирует работу трём важным функциям:
    
    - `sub_180001390`: некий обработчик состояний или логики входа,
    - `sub_180001220`: скорее всего, инициализация или установка хуков,
    - `sub_1800014F8`: возможно, код внедрения или создание потоков.

Чтобы понять **роль `Resources.Craft`**, нужно:

1. **Посмотреть, что делает `sub_180001220`** — именно она вызывается при загрузке DLL.
2. Проверить, **что делает `sub_1800014F8`** — особенно если она создаёт поток, вызывает `lstrcmp`, `CreateRemoteThread`, `WriteProcessMemory`, `VirtualAlloc`, и т.п.
3. Посмотреть, изменяет ли DLL поведение процесса, **хукает ли** какие-то функции, или **патчит память**.

**sub_180001220**:

```c
__int64 __fastcall sub_180001220(__int64 a1, int a2)
{
  if ( a2 == 1 )
    return sub_180001000(a1);
  else
    return 1;
}
```

Функция `sub_180001220` выглядит как простая обертка, которая выполняет проверку значения второго параметра `a2` и на основе этого либо вызывает другую функцию (`sub_180001000`), либо возвращает фиксированное значение (`1`).

- Если мы знаем, что функция `sub_180001000` выполняет более сложные действия с параметром `a1`, это может быть важным моментом в анализе, поскольку таким образом она будет вызвана только при конкретных условиях.
    
- В случае, если `a2` не равен 1, эта функция просто возвращает значение 1, что может быть использовано как стандартное или "ошибочное" значение.

- Проверить, что делает функция `sub_180001000`, так как от её результата зависит, что вернет `sub_180001220`.
    
- Обратить внимание на то, почему именно значение `1` является ключом для вызова `sub_180001000` — это может быть связано с проверками, валидацией или защитой от некоторых типов атак.


Понимание того, как и когда вызывается `sub_180001000`, может помочь в дальнейшем анализе.

**sub_180001000**:

```c
_BOOL8 sub_180001000()
{
  unsigned __int8 i; // [rsp+20h] [rbp-78h]
  char v2; // [rsp+21h] [rbp-77h]
  char v3; // [rsp+22h] [rbp-76h]
  unsigned __int64 j; // [rsp+28h] [rbp-70h]
  void *v5; // [rsp+30h] [rbp-68h]
  FARPROC lpAddress; // [rsp+38h] [rbp-60h]
  HMODULE hModule; // [rsp+48h] [rbp-50h]
  DWORD flOldProtect; // [rsp+50h] [rbp-48h] BYREF
  DWORD v9; // [rsp+54h] [rbp-44h] BYREF
  void *v10; // [rsp+58h] [rbp-40h]
  _WORD v11[6]; // [rsp+60h] [rbp-38h] BYREF

  hModule = LoadLibraryA("kernel32");
  if ( !hModule )
    return 0;
  v5 = VirtualAlloc(0, 0xBB8u, 0x3000u, 0x40u);
  qmemcpy(v5, &unk_18006F000, 0xA60u);
  v2 = 5;
  for ( i = 0; i < 0x64u; ++i )
  {
    v3 = sub_180001260(v5, 2656);
    for ( j = 0; j < 0xA60; ++j )
      *((_BYTE *)v5 + j) ^= v2;
    v2 -= v3;
  }
  v11[0] = -18360;
  v11[5] = -7937;
  v10 = v5;
  *(_QWORD *)&v11[1] = v5;
  lpAddress = GetProcAddress(hModule, "lstrcmpW");
  if ( !lpAddress )
    return 0;
  if ( !VirtualProtect(lpAddress, 7u, 0x40u, &flOldProtect) )
    return 0;
  qmemcpy(lpAddress, v11, 0xCu);
  return VirtualProtect(lpAddress, 7u, flOldProtect, &v9);
}
```

Теперь становится **абсолютно ясно**, что делает наш DLL, и в частности, как связана часть под названием `Resources.Craft` — мы смотрим на фазу **внедрения и внедрённого патча** в ядро `kernel32.dll`.

Эта функция:

1. Загружает `kernel32.dll`.
2. Выделяет память.
3. Расшифровывает некий **зашифрованный фрагмент** (возможно, shellcode).
4. Патчит **`lstrcmpW`** внутри `kernel32.dll`, внедряя туда этот расшифрованный код.
5. Возвращает флаг успешности.

По сути — это **инжектор shellcode-а в стандартную API-функцию Windows**.

```c
hModule = LoadLibraryA("kernel32");
v5 = VirtualAlloc(0, 0xBB8u, 0x3000u, 0x40u);
qmemcpy(v5, &unk_18006F000, 0xA60u);

v2 = 5;
for ( i = 0; i < 0x64u; ++i )
{
  v3 = sub_180001260(v5, 2656);
  for ( j = 0; j < 0xA60; ++j )
    *((_BYTE *)v5 + j) ^= v2;
  v2 -= v3;
}


lpAddress = GetProcAddress(hModule, "lstrcmpW");

if ( !VirtualProtect(lpAddress, 7u, 0x40u, &flOldProtect) )
    return 0;
qmemcpy(lpAddress, v11, 0xCu);

v11[0] = -18360;         // Возможно, jmp-опкод или вызов
v11[5] = -7937;          // Часть адреса
*(_QWORD *)&v11[1] = v5; // Адрес shellcode-а`

```

1. Загружает хендл к модулю `kernel32.dll` (по сути, подгружает или возвращает уже загруженный).

2. Выделяется память размером **3000 байт (0xBB8)** с флагом `PAGE_EXECUTE_READWRITE`. Это — будущий контейнер расшифрованного shellcode-а.

3. `unk_18006F000` — это зашифрованный payload, хранящийся **в теле DLL**, скорее всего как ресурс или бинарный блок данных (возможно, `Resources.Craft` как ты и упоминал).

4. Происходит **многократное XOR-обфусцирование**, в каждом цикле сдвигается ключ. Функция   `sub_180001260` — возможно, вычисляет некий контрольный байт или checksum, влияющий на ключ. После этого в `v5` уже содержится **дешифрованный код**.

5. Находит адрес `lstrcmpW` в `kernel32.dll`.

6. Меняет права на участок памяти с `lstrcmpW` на `PAGE_EXECUTE_READWRITE`. Копирует 12 байт из `v11` (частично инициализированный буфер, но судя по коду — это trampoline).

По всей видимости — это **перезапись начала `lstrcmpW`**, чтобы сделать `jmp v5`.


```c
return VirtualProtect(lpAddress, 7u, flOldProtect, &v9);
```

Возвращает прежнюю защиту страницы.

- `Resources.Craft` — **контейнер зашифрованного shellcode-а**;
    
- Его расшифровка происходит в `sub_180001000`, а потом уже активируется через подмену `lstrcmpW`.

Функция `sub_180001000` внедряет дешифрованный shellcode в память, а затем **хукает `lstrcmpW`**, чтобы при следующем её вызове перейти на этот shellcode.

1. Посмотреть содержимое `unk_18006F000` — это наш шифрованный payload.
2. Разобрать `sub_180001260` — может быть интересна логика ключей/обфускации.
3. В отладчике отследить вызов `lstrcmpW` — ты должен попасть в shellcode.
4. Можно выдернуть `v5` и дизассемблировать его отдельно.

Я изначально пытался извлечь значение из переменной `unk_18006F000`, чтобы его декодировать и затем проанализировать shellcode — с целью разобраться, где именно находится нужный мне код. Однако эта попытка оказалась неудачной.

1. **Я хотел извлечь `unk_18006F000`** из DLL (размер: `0xA60` = 2656 байт).

```bash
dd if=your.dll of=unk_18006F000.bin bs=1 skip=OFFSET count=2656
```

2. **Запусти скрипт**, получишь расшифрованный shellcode.

```python
def decrypt_shellcode(data: bytes) -> bytes:
    buf = bytearray(data)
    key = 5

    for _ in range(100):  # 0x64
        v3 = 0
        for b in buf:
            v3 ^= b  # примерная логика sub_180001260, может быть иной
        for i in range(len(buf)):
            buf[i] ^= key
        key = (key - (v3 & 0xFF)) & 0xFF  # имитация байтового переполнения

    return bytes(buf)

# Загрузка файла с шифрованным блоком
with open("unk_18006F000.bin", "rb") as f:
    encrypted = f.read()

# Расшифровка
decrypted = decrypt_shellcode(encrypted)

# Сохраняем для анализа
with open("decrypted_shellcode.bin", "wb") as f:
    f.write(decrypted)

print("[+] Расшифровка завершена, сохранено в decrypted_shellcode.bin")
```

- **Дизассемблировать результат**:
    
    - в `Ghidra` (через "Import Raw Binary")
    - или в `IDA Free` как `Manual Load`
    - или `ndisasm` / `capstone` / `radare2`.

Однако процесс затянулся, и я решил сменить подход, выбрав другой путь для анализа.

## x64dbg в деле: вскрываем исполняемый файл

В итоге я принял решение продолжить анализ с использованием x64dbg. Я загружаю приложение в x64dbg и дожидаюсь его полной инициализации. Поскольку Windows-программы при работе в отладчике являются слишком «шумным», нужно заранее продумывать чёткий маршрут по коду, чтобы не потеряться в море инструкций.

Давайте проанализируем, какие библиотеки загружаются при запуске и какие функции из них вызываются.

![](/assets/Pastedimage20250426015302.png)

Это именно та библиотека, которая была загружена из ресурсов программы — мы можем проследить момент её загрузки и увидеть, какие функции она при этом вызывает. Если потребуется проанализировать код, достаточно дважды кликнуть, чтобы перейти к месту, где он начинается.

![](/assets/Pastedimage20250426015712.png)

Это как раз тот участок кода, где вычисляется адрес инструкции `lstrcmpW`. Однако мы уже ранее изучили эту библиотеку в IDA и знаем, что она модифицирует инструкцию `lstrcmpW`, расположенную в `kernel32.dll`. Теперь наша задача — найти `kernel32.dll` в памяти, чтобы проверить, какие изменения были внесены в функцию `lstrcmpW`.

![](/assets/Pastedimage20250426020336.png)

Чтобы не отвлекаться на лишние детали и не перегружать глаза, я воспользовался фильтром для упрощения отображения информации.

Переходим к анализу функции `lstrcmpW` (двойной клик):

![](/assets/Pastedimage20250426020713.png)

Переходим по адресу, на который указывает адрес.

![](/assets/Pastedimage20250426020950.png)

Теперь мы видим функцию `lstrcmpW`. Давайте посмотрим, какие изменения были внесены в неё со стороны динамической библиотеки которая загружается с ресурса.

![](/assets/Pastedimage20250426021339.png)

Когда я прокрутил инструкции немного ниже, я заметил формат флага, но его значение не совпадало с эталонным, с которым оно должно было быть сравнино после отправки флага.

![](/assets/Pastedimage20250426021640.png)

Собрав все символы, я получил новый флаг: 

```
virlab{Nu_nak0n3c_ty_p0b3d1l_3t0t_suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuup3r_sl0zhnyy_k1taysk1y_kr3k}

```

Размер флага составляет 100 байт, что соответствует заданному условию `if`. в начале. 

Проверяем:

![](/assets/Pastedimage20250426022322.png)

И БИНГО! Это действительно оказался наш настоящий флаг. Поздравляем себя с успешным решением!


